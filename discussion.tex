In this work, we used Ruxanne to successfully mine 20 cross-project bug fix patterns. We presented these patterns in two groups: 12 general patterns and 8 BC-related patterns. Clippy is able to detect five of the BC-related patterns. Fundamentally, Clippy cannot detect some of the remaining patterns. For instance, we proposed the pattern \textit{Adding mutability}. In the Rust context, this change anticipates a future change to the code which will perform a mutation of a previously immutable value. Predicting the future is beyond Clippy's remit. To the best of our knowledge, the rest of the patterns (3 BC-related patterns and 12 general patterns) cannot be reported by the current linting tools. 

In each group, we categorized the bug fix patterns based on their underlying program element. The patterns encompass a wide variety of program elements both in the general and BC-related groups. This supports a conclusion that our weighting scheme is not biased towards specific program elements. Also, our patterns are all cross-project fix patterns: each reported fix pattern has been seen at least in three different projects.

All of our parsing, path extraction, weighting scheme, and clustering modules, along with our final results, can be found in our replication package, which we provide for verification, reusability and further extension. Weightings can be modified to make the embedding focus on a specific set of elements for building different code embeddings.

\subsection{Patterns Present and Missing}

When presenting each pattern, we discussed actionability for the most important actions. Here, we discuss the implications of our most important patterns.

The two most common patterns were general patterns modifying struct fields and attributes, with 179 and 172 instances respectively. Unfortunately, struct field modifications are neither interesting nor actionable; they are simply used to enable other changes. Attribute modifications are far more interesting, and account for the second- and fifth-most popular pattern. From a language design perspective, the fact that there are so many attribute changes marked as bug fixes illustrates the semantic importance of attributes in Rust, and implies that program repair must understand attributes. A further challenge is that different attributes have different, and often library-dependent, semantic meanings. Proposing specific repair techniques that reason about attributes is beyond the scope of this work, but our results suggest that they are important to develop.

The most common borrow-checker-related pattern and third-most-common pattern overall is dropping \texttt{clone()}. This pattern is performance-related; when correctly applied, it has no semantic impact on the program, but reduces resource consumption. Rust is used in situations where performance is important; the number of instances of this pattern confirms that developers do work on performance issues. This implies that program repair tools would benefit from being performance-aware, rather than limiting themselves strictly to functional properties of the code.

The fourth- and sixth-most popular patterns, changing the type of a struct field or of a generic type parameter, are difficult to make general statements about; there are many unrelated idiosyncratic changes in these clusters. Such changes look the same, but have different purposes. One example we showed changed a \texttt{HashMap} to an \texttt{IndexMap}, preserving iteration order. That specific nondeterminism bug could be automatically repaired upon direction from the developer. Another change modified \texttt{usize} to \texttt{isize}, perhaps reflecting a requirements change to allow signed integers. IDEs could support refactorings that modify types. We find it difficult to propose further general work in this direction.

The seventh-most-popular pattern is the Rust-specific change of dropping mutability (i.e. making data immutable). Tools like ReImInfer by~\cite{HuangMDE2012} (for a Java extension), and techniques like the one proposed in~\cite{EyolfsonAbstractImmutability} for C++, aim to infer that data is immutable. In the Rust context, it is easier to make data immutable: the semantics for immutability are clear. Immutability is part of the core Rust language. mmutability escape hatches in C++ complicate issues, but in Rust, the escape hatch is the clearly-marked \texttt{unsafe} block. This pattern thus suggests that tools for inferring Rust immutability could be viable.

We are unable to say anything meaningful about the eighth- and ninth-most popular patterns, \texttt{G.match.pattern} and \texttt{G.type.enum.variant}. They do not seem particularly helpful for automatic program repair.

The tenth-most-popular pattern, making a struct field \texttt{pub} and hence visible to external modules, suggests that tools to help developers manage visibility would be helpful. Public accessibility of methods and fields very much affects library compatibility and usability.

Conversely, we were surprised to find that Ruxanne reported no patterns associated with certain Rust-related features. For instance, we did not observe any patterns associated with the Rust \verb+move+ operator, which has been known to trouble many beginning Rust programmers. \verb+move+ is used to transfer the ownership of values to a closure. In some cases (e.g. multithreading), not moving the ownership could create invalid references. Rust compiler checks prevent such errors. Our speculation is that, since Rust enforces strict compiler checks, programmers usually get many compile-time errors, but they only push their code once it is free of compile errors. We thus would not observe patterns which do not make it to the repository.

\subsection{Usefulness of Rust Bug Patterns}

We believe our results can help with the development of IDE and program repair tools for Rust. We have discussed the actionability of some of the general patterns and three BC-related patterns that are not detected by Clippy. For instance, as we have discussed, for the common pattern of \textit{Modifying the attributes of structs}, a code linter tool could search for correct attribute lists within the codebase~\citep{forrest2009genetic}, leveraging the assumption that proper attribute usage can be found elsewhere. Also, the linter can analyze the usages of the struct to determine the necessity of adding the attribute. Removing unnecessary attributes not only optimizes the codebase but also eliminates unnecessary overhead and reduces binary size. Similarly, we presented the pattern \textit{Dropping clone and adding borrowing}. As discussed, Clippy does not detect this pattern, and repetitive clones can be computationally expensive. Using state-of-the-art methods for program repair, one could design a tool to recognize this pattern and change variable cloning to simple borrowing. These findings and insights can greatly aid researchers in creating effective IDE tools tailored for Rust development. Moreover, the empirical frequency numbers associated with each pattern, highlighting its prevalence, can provide valuable guidance for the development of program repair tools.

A general approach for code embedding is to extract paths with semantic information that better serve a given embedding goal. For instance, to design an embedding method for repairing Rust programs, the designer might want to disregard certain elements, such as moving ownership to closure bodies. Such elements may be irrelevant for repair because they did not appear in the bug patterns that we presented.


\subsection{Threats to Validity}

In our work there are two main threats to internal validity: (1) A threat to internal validity is confounding, where changes to what shows up in the embedding are not due to changes in the code being embedded. In this case, the weighting scheme may contribute to confounding because we manually adjusted the weights. Nevertheless, our weighting scheme can be readjusted to find different patterns, which is why we made our pipeline publicly available. (2) Our code embedding approach is based on the frequency of observed program elements in ASTs, and we use DBSCAN as our clustering algorithm. Other code embedding methods and clustering algorithms (e.g. SLINK) might output new clusters that our pipeline is unable to find. A threat to external validity is selection bias, where the benchmarks differ systematically from the actual world. The selected projects might cause selection bias and therefore we might not have presented patterns that may exist in other projects. Another threat to external validity can be the developers reporting the commits as bug fixing commits while they are not really fixing a functionality. Similarly, a commit message might not contain our target keywords while the commit is associated with bug fixing changes.
