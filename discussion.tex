In this work, our pipeline successfully mined 19 cross project bug fix patterns. However, our pipeline fails to detect complex pattern due to space limitation and their innate complicated features. A complicated pattern is a pattern that includes many changes in many places and it makes it easier for two datapoints to be dissimilar. 

Also, we expected to obtain certain patterns regarding some ertain Rust related features, such as unsafe Rust, but our results did not include those patterns. Our speculation is that, since Rust has a strong compiler check before creating the program executable, the programmers usually get many errors, and they only push their code once it is free of compile errors. That is why, we think there are some patterns that were hidden from our sight.

We believe our results can help researchers to create Rust tools for repair, fault localization, IDE linters, and etc. Also, these results can help program embedding methods to focus on more important aspects of a program and shrink down information more effectively.

\subsection{Threats to Validity}

In our work there are three main threats to internal validity: (1) We use a weighting scheme which is based on a heuristic to give more values to tree elements closer to the leaves. In addition to that, we also manually adjusted the weights of borrow checker related elements to respect ownership framework's role in Rust, though we recorded their results separate from general results. As this approach is based on an intuition, it does not guarantee achieving optimal clusters. (2) The collected commits are the ones that fix a bug in a previously pushed commit. We do not consider the bugs that occur during a commit and also fixed during the same commit. (3) Our data modelling approach is based on the frequency of observed program elements in ASTs, and we use DBSCAN as our clustering algorithm. Other program data modelling methods and clustering algorithms (e.g.SLINK) might output new clusters that our pipeline is unable to find. 

The threat to external validity can be the developers reporting the commits as bug fixing commits while they are not really fixing a functionality. Similarly, a commit message might not contain our target keywords while the commit is associated with bug fixing changes.
