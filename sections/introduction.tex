Bugs have long been an unavoidable part of computer programming, predating Grace Hopper's literal debugging session in 1947; even today, bug-free software remains an aspirational goal for software engineering research. One step towards that goal has been studying common bug patterns (and their corresponding fixes) across multiple software systems. Research efforts categorizing common bug patterns date back to at least 1975, where Endres tried to categorize bug patterns in operating system implementations~\cite{endres1975analysis}.  

In this work, we empirically analyze the most popular Rust projects in GitHub, aiming to discover common bug patterns that afflict these projects. Our interest comes from a desire to develop automated program repair tools, but we believe these insights can also be of broader service. Automated program repair~\cite{goues2019automated,liu2018survey} tools try to find bug locations in the source code (using a fault localization module) and then generate patches to fix them, possibly without human intervention, so that the modified program meets desired specifications (implicit or explicit). A powerful automated program repair system has many useful applications and could significantly simplify debugging, thus reducing software development cost~\cite{le2012systematic}. A set of common bug fix patterns can be a useful input to an APR system: it tells how to fix recurring buggy structures, thus reducing the search space for patch generation~\cite{jeffrey2009bugfix}. 

If we observe undesired behaviour from our program, then there is likely a fault within our program\footnote{At the extreme, a fault could be caused by moths or other hardware malfunctions.}. But where is the fault? Fault localization~\cite{wong2016survey} is the process of automatically finding faulty statements in a program. If a fault localization tool knows about the common bug patterns that can appear in the underlying programming language, it can prioritize candidates based on their bug-producing potential. That would result in a more robust tool---one that leverages historical data.

Moreover, knowing that certain code patterns in a programming language are more susceptible to bugs enables projects to set policies that avoid such patterns. For instance, in the context of C and C++, Cannon et al~\cite{Cannon1997RecommendedCS} recommend that, if at least one of the if/else sections is a compound statement, requiring braces, then both sections should have braces (i.e. they should be fully bracketed). This recommendation presumably comes from qualitative experience, as it pre-dates large-scale empirical studies. A project can choose to require that contributions follow such recommendations. Research such as ours can help formulate data-driven recommendations that reduce the number of patterns empirically linked to bugs. Per Monperrus, the fewer frequent bug patterns we keep in our software, the lower cost we can expect to pay for software maintenance~\cite{monperrus2014critical}.

Moving further afield, researchers have been exploiting deep learning techniques to create program modifier models, which can then be used for specific goals (e.g. bug fixes)~\cite{alon2019code2vec,alon2018general,raychev2016learning,bielik2016phog}. However, most extant learning tools take fixed-size vectors as inputs. The process of compressing a variably-sized program to a fixed-sized vector is called code embedding~\cite{chen2019literature}. Unlike with image data, it is challenging to compress programs into vectors without any semantic information loss. Current approaches try to define the dimensions of the fixed-sized vectors in a way that accounts for all possible abstract syntax tree forms. That results in a large, sparse space for the inputs. Assuming that the deep learning model we are trying to develop is used for bug fixing, then knowledge about common bug fix patterns can help prune the dimensionality of the input space, which can help create more efficient embeddings.

Many studies have investigated detecting and categorizing bug fix patterns in general~\cite{islam2021changes,madeiral2018towards,pan2009toward}, or for a specific programming language~\cite{yang2022mining,hanam2016discovering,campos2019discovering}. In this work, we study common bug patterns that appear in Rust projects. Rust is a relatively new programming language~\cite{klabnik2019rust} which allows programmers to write programs that have low-level control over resources, while still ensuring high-level safety guarantees (for programs written in safe Rust). What distinguishes Rust from the other systems programming languages, e.g. C/C++, is its ownership framework, which is an integral part of Rust. The ownership framework keeps track of references to different memory locations, and will free them once they go out of scope. If a program passes the compiler’s checks, it meets several safety properties by construction; e.g. it has no dangling references or double-frees. Such properties had to be manually ensured (or not!) in languages like C/C++. Moreover, not only does ownership remove the need for a garbage collector in the runtime environment, it frees the programmer from the need to explicitly do certain safety-related tasks~\cite{qin2020understanding}. Due to the memory and thread safety guarantees that Rust provides, many software companies have adopted Rust in production. For example, Dropbox decided to migrate to Rust for developing their storage system, since they were not completely satisfied with the features provided by AWS’s S3 or Golang~\cite{dropbox}.

The Rust compiler's Borrow-Checker component enforces ownership rules and hence many of Rust's safety properties. Because of the Borrow-Checker's importance in Rust, we split the patterns that we present into two groups: (1) non-borrow-checker related patterns (General Patterns), and (2) borrow-checker related patterns (BC-Related Patterns). \\

\noindent \textbf{Research Questions} We formulated three research questions (RQs) which guided our empirical study about Rust bug patterns:

\begin{itemize}
    \item \textbf{RQ1. Does our data modelling approach capture the most important aspects of bug-fixing program changes?} 
    \item \textbf{RQ2. What are the general fix patterns in Rust, and how often do they apply?} 
    \item \textbf{RQ3. What are borrow-checker related fix patterns in Rust, and how often do they apply?}
\end{itemize}

\noindent \textbf{Contributions} This paper makes the following primary contributions:

\begin{itemize}
    \item To the best of our knowledge, this work is the first to exploits a code analysis pipeline to automatically mine Rust open source projects and extract common cross-project bug fix patterns.
    \item We propose a novel method to encode key AST information in fixed size datapoints using a semi-automatically derived weighting scheme.
    \item To respect the key role of the borrow checker in Rust, we report and discuss bug fix patterns that are related to the ownership framework in Rust separately from general patterns.
\end{itemize}


