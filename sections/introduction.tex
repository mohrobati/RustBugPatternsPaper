Producing bugs has been an unavoidable part of computer programming. Researchers have been trying to help software engineers to be more aware of the bug producing practices in development and how to step towards creating bug-free software. One useful step towards that goal would be studying common bug patterns (and their corresponding fixes) that occur across multiple software systems. Research efforts for categorizing common bug patterns date back to 1975 where Endres tried to categorize various bug patterns which occurred in operating system implementations~\cite{endres1975analysis}.  

In this work, we empirically analyze the most popular Rust projects in GitHub, aiming to discover common bug patterns that these projects share. Our interest comes from a desire to develop program repair tools, but we believe these insights can also be of broader service. Automated program repair~\cite{goues2019automated,liu2018survey} tools try to locate bug locations in the source code (using a fault localization module) and then generate patches to fix them, possibly without human intervention, so that the modified program meets desired specifications (implicit or explicit). A powerful automated program repair system has many useful applications and could significantly simplify debugging, thus reducing software development cost~\cite{le2012systematic}. A set of common bug fix patterns can be a useful input to an APR system: it directly provides information about fixing similar buggy structures, which can significantly reduce the search space for patch generation~\cite{jeffrey2009bugfix}. 

Similarly, if we are observing undesired behaviour from our program, that would indicate that there lies a fault within our program. But where is the fault? Fault localization~\cite{wong2016survey} is the process of automatically finding the faulty statement(s) in our program. If a fault localization tool knows about the common bug patterns that can appear in the underlying programming language, it can prioritize code segment candidates based on their potentials of producing bugs. That would result in a more robust tool that leverages historical data.

Moreover, knowing which code patterns in a programming language are more susceptible to bugs can help programmers to be more cautious while working with similar code structures. This knowledge can make the developers avoid certain mistakes during production which ultimately would result in reducing the frequent bug patterns within the program. As Monperrus describes, the fewer frequent bug patterns we keep in our software, the less cost we would have to pay for software maintenance~\cite{monperrus2014critical}.


Moving further afield, researchers have been exploiting deep learning techniques to learn about the semantics of computer programs and create program modifier models that have a specific goal (e.g. bug fix)~\cite{alon2019code2vec,alon2018general,raychev2016learning,bielik2016phog}. However, most learning tools get fixed-size vectors as input and map them to outputs. Unlike image data, it is challenging to compress programs into vectors without any semantic information loss. Current approaches try to define the vector dimensions in a way that accounts for all possible abstract syntax tree forms. That results in a large, sparse space for the inputs. Assuming that the deep learning model we are trying to develop is associated with bug fixing tasks, then knowledge about common bug fix patterns can help prune the input space towards containing fewer dimensions. That can help with creating more efficient models.


Many studies have investigated detecting and categorizing bug fix patterns in general~\cite{islam2021changes,madeiral2018towards,pan2009toward}, or for a specific programming language~\cite{yang2022mining,hanam2016discovering,campos2019discovering}. In this work, we study common bug patterns that appear in Rust projects. Rust is a relatively new language that allows programmers to write programs that have low-level control over resources, as well as high-level safety guarantees~\cite{klabnik2019rust}. What distinguishes Rust from the other systems programming languages, e.g. C/C++, is its ownership framework, which is an integral part of Rust. The ownership framework keeps track of references to different memory locations, and will free them once they go out of scope. If a program passes the compiler’s checks, it must meet several safety properties; e.g. it has no dangling references or double-frees. These problems had to be manually ensured in languages like C/C++. Moreover, not only does the ownership concept remove the need for a garbage collector in the runtime environment, it does not require the programmer to explicitly do certain safety tasks~\cite{qin2020understanding}. Due to the memory and thread safety guarantees that Rust provides, many software companies adopted Rust in production. For example, Dropbox decided to migrate to Rust for developing their storage system, since they were not completely satisfied with the features provided by AWS’s S3 or Golang~\cite{dropbox}.

In Rust, the so-called Borrow Checker component enforces ownership rules. Because of the Borrow Checker's importance in Rust, we split patterns into two groups: (1) non-borrow-checker related patterns (General Patterns), and (2) borrow-checker related patterns (BC-Related Patterns). \\

\noindent \textbf{Research Questions} We present our discovered insights of our empirical study in the following four research
questions (RQs):

\begin{itemize}
    \item \textbf{RQ1. Does our data modelling approach capture the most important aspect of program changes?} 
    \item \textbf{RQ2. What are the general fix patterns in Rust, and how often do they apply?} 
    \item \textbf{RQ3. What are borrow-checker related fix patterns in Rust, and how often do they apply?}
\end{itemize}



\noindent \textbf{Contribution} This paper makes the following primary contributions:

\begin{itemize}
    \item To the best of our knowledge, this work is the first project that exploits a code analysis pipeline to automatically mine Rust open source projects and extract the common cross project bug fix patterns.
    \item We propose a novel method to encode key AST information in fixed size datapoints using a semi-automatically derived weighting scheme.
    \item To respect the role of borrow checker in Rust, our paper reports and discusses the bug fix patterns that are related to the ownership framework in Rust separate from the general patterns.
\end{itemize}


