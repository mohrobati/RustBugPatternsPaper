Rust is a relatively new programming language~\citep{klabnik2019rust} which allows programmers to write programs that have low-level control over resources, while still ensuring high-level safety guarantees (for programs written in safe Rust). What distinguishes Rust from the other systems programming languages, e.g. C/C++, is its ownership framework, which is an integral part of Rust. The ownership framework keeps track of references to different memory locations, and will free them once they go out of scope. If a program passes the compiler’s checks, it meets several safety properties by construction; e.g. it has no dangling references or double-frees. Such properties had to be manually ensured (or not!) in languages like C/C++. Moreover, not only does ownership remove the need for a garbage collector in the runtime environment, it frees the programmer of the responsibility to ensure certain safety-related properties~\citep{qin2020understanding}. Due to the memory and thread safety guarantees that Rust provides, many software companies have adopted Rust in production. For example, Dropbox decided to migrate to Rust for developing their storage system, since they were not completely satisfied with the features provided by AWS’s S3 or Golang~\citep{dropbox}.

Bugs have long been an unavoidable part of computer programming, predating Grace Hopper's literal debugging session in 1947; even today, bug-free software remains an aspirational aim for software engineering research. One step towards that aim has been studying common bug patterns (and their corresponding fixes) across multiple software systems. Research efforts categorizing common bug patterns date back to at least 1975, where \cite{endres1975analysis} tried to categorize bug patterns in operating system implementations.  

In this work, with the help of our tool, Ruxanne, we empirically analyze the most popular Rust projects in GitHub. Our goal is to discover common bug patterns that afflict these projects. Although we are motivated by a desire to develop automated program repair tools, we believe these insights can also be of broader service. Automated program repair~\citep{goues2019automated,liu2018survey} tools try to find bug locations in the source code (using a fault localization module) and then generate patches to fix them, possibly without human intervention, so that the modified program meets desired specifications (implicit or explicit). A powerful automated program repair system has many useful applications and could significantly simplify debugging, thus reducing software development cost~\citep{le2012systematic}. A set of common bug fix patterns can be a useful input to an APR system: it tells how to fix recurring buggy structures, thus reducing the search space for patch generation~\citep{jeffrey2009bugfix}. 
Yet, to the best of our knowledge, no research has sought to identify the most pervasive bug fix patterns in Rust programs. In this project, we introduce Ruxanne, a tool for analyzing and extracting fix patterns in Rust. Ruxanne uses a novel embedding of Rust code into fixed-sized vectors. Through Ruxanne, we mined the top 18 most-starred Rust projects in Github to discover the most common bug fix patterns committed to their repositories. We analyzed 87,726 code changes drawn from 57,214 commits across these 18 projects. After clustering the code changes, and conducting a manual analysis, we discovered 20 groups of cross-project bug fix patterns, which we categorize as (1) general patterns and (2) borrow-checker-related patterns. We describe each of these patterns and their implications to automated program repair.

If we observe undesired behaviour from our program, then there is likely a fault within our program\footnote{At the extreme, a fault could be caused by moths or other hardware malfunctions.}. But where is the fault? Fault localization~\citep{wong2016survey} is the process of automatically finding faulty statements in a program. If a fault localization tool knows about the common bug patterns that can appear in the underlying programming language, it can prioritize candidates based on their bug-producing potential. That would result in a more robust tool---one that leverages historical data.

Moreover, knowing that certain code patterns in a programming language are more susceptible to bugs enables projects to set policies that avoid such patterns. For instance, in the context of C and C++, \cite{Cannon1997RecommendedCS} recommend that, if at least one of the if/else sections is a compound statement, requiring braces, then both sections should have braces (i.e. they should be fully bracketed). This recommendation presumably comes from qualitative experience, as it pre-dates large-scale empirical studies. A project can choose to require that contributions follow such recommendations. Research such as ours can help formulate data-driven recommendations that reduce the number of patterns empirically linked to bugs. Per Monperrus, the fewer frequent bug patterns we keep in our software, the lower cost we can expect to pay for software maintenance~\citep{monperrus2014critical}.

Moving further afield, researchers have been exploiting deep learning techniques to create program modifier models, which can then be used for specific goals (e.g. bug fixes)~\citep{alon2019code2vec,alon2018general,raychev2016learning,bielik2016phog}. However, most extant learning tools take fixed-size vectors as inputs. The process of compressing a variably-sized program to a fixed-sized vector is called code embedding~\citep{chen2019literature}. Unlike with image data, it is challenging to compress programs into vectors without any semantic information loss. Current approaches try to define the dimensions of the fixed-sized vectors in a way that accounts for all possible abstract syntax tree forms. That results in a large, sparse space for the inputs. Assuming that the deep learning model we are trying to develop is used for bug fixing, then knowledge about common bug fix patterns can help prune the dimensionality of the input space, which can help create more efficient embeddings.

Many studies have investigated detecting and categorizing bug fix patterns in general~\citep{islam2021changes,madeiral2018towards,pan2009toward}, or for a specific programming language~\citep{yang2022mining,hanam2016discovering,campos2019discovering}. In this work, we study common bug patterns that appear in Rust projects. The Rust compiler's Borrow-Checker component enforces ownership rules and hence many of Rust's safety properties. Because of the Borrow-Checker's importance in Rust, we split the patterns that we present into two groups: (1) non-borrow-checker related patterns (General Patterns), and (2) borrow-checker related patterns (BC-Related Patterns). \\

\noindent \textbf{Research Questions} We formulated three research questions (RQs) which guided our empirical study about Rust bug patterns:

\begin{itemize}
    \item \textbf{RQ1. Does our code embedding approach capture the most important aspects of bug-fixing program changes?} 
    \item \textbf{RQ2. What are the general fix patterns in Rust, and how often do they apply?} 
    \item \textbf{RQ3. What are borrow-checker related fix patterns in Rust, and how often do they apply?}
\end{itemize}

\noindent \textbf{Contributions} This paper makes the following primary contributions:

\begin{itemize}
    \item To the best of our knowledge, this work is the first to exploit a code analysis pipeline to automatically mine Rust open source projects and extract common cross-project bug fix patterns.
    \item This work proposes a novel method to encode key AST information in fixed size datapoints using a semi-automatically derived weighting scheme.
    \item Keeping in mind the key role of the borrow checker in Rust, this work specifically identifies bug fix patterns that are related to Rust's ownership framework in addition to general bug fix patterns for Rust.
    \item We identified that the most frequently observed general pattern is the addition or removal of struct fields. Among the BC-related patterns, we found that the most common pattern is the removal of a clone() call. 
\end{itemize}

\noindent \textbf{Data Availability Statement} The datasets generated and analyzed during the current study are available in the Zenodo repository, \url{https://zenodo.org/record/7388618}.
